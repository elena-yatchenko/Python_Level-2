# СПИСКИ LIST
# list - динамический массив, т.е. может изменяться
"""РАБОТА СО СПИСКАМИ
- list() или [] - создание
- [] - доступ к элементу по индексу (например, list[2] - элемент с индексом 2)
- append() метод - добавление 1 элемента в конец
- extend() метод  - добавление нескольких элем-в в конец
- pop() - удаление элемента по индексу
- count() - подсчет вхождения элемента
- index() - индекс первого вхождения элемента
- insert() - вставка элемента по индексу
- remove() - удаление элемента по значению """

# list_1 = list() # пустой список
# list_2 = list(3.14, True, 'text') # список с заданными элементами
# list_3 = [] # пустой список
# list_4 = [3.14, True, 'text'] # список с заданными элементами

# my_list = [2, 4, 6, 8, 10, 12]
#         #    0  1  2  3   4   5
#         #   -6 -5 -4 -3  -2  -1
# print(my_list[0]) # 2
# print(my_list[-1]) # 12 При отрицательной индексации обращаемся к элементам списка справа налево, начинается с -1
# print(my_list[6]) # IndexError: list index out of range
# print(my_list[-10]) # IndexError: list index out of range

# APPEND() - в качестве аргумента - ОБЪЕКТ (переменная) или конкретное ЗНАЧЕНИЕ элемента, который хотим добавить

# a = 42
# b = 'text'
# c = [1, 3, 5, 7]
# my_list = [None]
# print(my_list) # [None]
# my_list.append(a)
# print(my_list) # [None, 42]
# my_list.append(b)
# print(my_list) # [None, 42, 'text']
# my_list.append(c)
# print(my_list) # [None, 42, 'text', [1, 3, 5, 7]]
# my_list.append(125)
# print(my_list) # [None, 42, 'text', [1, 3, 5, 7], 125]

# my_list.append(my_list)
# print(my_list) # [None, 42, 'text', [1, 3, 5, 7], [...]] - по сути создали ЦИКЛИЧЕСКУЮ ССЫЛКА, когда объект
# # ссылается сам на себя. Не допускать этого в программих

# EXTEND() - в качестве аргумента - ПОСЛЕДОВАТЕЛЬНОСТЬ (итерируемый элемент).
"""фукнция добавляет элементы указанной последовательности, но ничего не возвращает. Например, print() даст None"""

# a = 42
# b = 'text'
# c = [1, 3, 5, 7]
# my_list = [None]
# print(my_list) # [None]
# # my_list.extend(a)
# # print(my_list) # TypeError: 'int' object is not iterable - метод extend() НЕ работает с единичными объектами.
# # Ему нужна последовательность, которую он считывает слева направо и добавляет ПО ОДНОМУ ЭЛЕМЕНТУ ПОСЛЕДОВАТЕЛЬНО в наш список
# my_list.extend(b)
# print(my_list) # [None, 't', 'e', 'x', 't']
# my_list.extend(c)
# print(my_list) # [None, 't', 'e', 'x', 't', 1, 3, 5, 7]

# my_list.extend(my_list) # в этом случае сработает, добавив список по элементам еще раз. По сути удвоив его
# print(my_list) # [None, 't', 'e', 'x', 't', 1, 3, 5, 7, None, 't', 'e', 'x', 't', 1, 3, 5, 7]

# POP() -в качестве аргумента - ИНДЕКС элемента. (Возвращает в переменную удаленный элемент. Т.е. print() даст удаленный элемент)

""" pop() без аргумента - удаляет последний (крайний правый) элемент из списка, сохраняя его(удаленный элемент) при этом в переменную
которая указана слева от знака "=". Т.е. мы одновременно сохраняем элемент в переменную, и удаляем его из исходного списка
pop(1) - с указанием индекса в КРУГЛЫХ скобках - удаляется элемент с указанным индексом, при этом так же он сохраняется в переменную.
Остальные элементы сдвигаются, чтоб заполнить пустую ячейку (может занимать время, если работа с большими массивами данных)
Если указываем несуществующий индекс - ошибка"""

# my_list = [2, 4, 6, 8, 10, 12]
# spam = my_list.pop()
# print(spam, my_list) # 12 [2, 4, 6, 8, 10]
# eggs = my_list.pop(1)
# print(eggs, my_list) # 4 [2, 6, 8, 10]
# err = my_list.pop(10) # IndexError: pop index out of range

# COUNT() - в качестве аргумента - ЗНАЧЕНИЕ элемента

# my_list = [2, 4, 6, 8, 10, 12, 2, 4, 14, 2]
# spam = my_list.count(2)
# print(spam) # 3
# eggs = my_list.count(3)
# print(eggs) # 0

# INDEX() - в качестве аргумента - ЗНАЧЕНИЕ элемента

"""index() в аргумент, кроме значения искомого элемента, может принимать на вход 2 дополнительных элемента: start и stop.
Т.е. позицию, с которой начинаем поиск, и до какой продолжаем """

# my_list = [2, 4, 6, 2, 8, 10, 12, 2, 4, 14, 2]
# spam = my_list.index(4)
# print(spam) # 1
# eggs = my_list.index(4, spam + 1, 90) # начинаем поиск элемента 4, начиная с индекса spam + 1 (т.е. с индекса 2) и до индекса 90
# print(eggs) # 8
# eggs = my_list.index(3)
# print(eggs) # ValueError: 3 is not in list (элемента со значением 3 нет в нашем списке)

# INSERT() - в качестве аргументов - ИНДЕКС и ЗНАЧЕНИЕ элемента

"""Принимает на вход 2 значения: 1 - позиция(индекс), куда хотим вставить элемент, 2 (через запятую) - сам элемент, который хотим добавить.
При этом, в отличие от замены, вставка подразумевает увеличение списка на 1 элемент """

# my_list = [2, 4, 6, 8, 10, 12]
# my_list.insert(2, 555) #  вставляем МЕСТО 2-ГО
# print(my_list) # [2, 4, 555, 6, 8, 10, 12]
# my_list.insert(-2, 13) # вставляем ПОСЛЕ -2-го
# print(my_list) # [2, 4, 555, 6, 8, 13, 10, 12]
# my_list.insert(42, 73) # т.к. индекс превышает размер списка, вставляется просто в конец списка (сработает как append())
# print(my_list) #  [2, 4, 555, 6, 8, 13, 10, 12, 73]

# REMOVE() - в качестве аргумента - ЗНАЧЕНИЕ элемента
"""remove() удаляет элементы по значению, а pop() - по индексу"""

# my_list = [2, 4, 6, 8, 10, 12, 6]
# my_list.remove(6) # идет слева направо в поисках указанного элемента. Как только нашел - удалил, список сдвинулся на 1 элемент влево.
# # при этом до второй 6-ки не дошел уже. 
# print(my_list) # [2, 4, 8, 10, 12, 6]
# my_list.remove(3) 
# print(my_list) # ValueError: list.remove(x): x not in list - нет искомого элемента в списке

# СОРТИРОВКИ И РАЗВОРОТЫ

"""
Сортировка - упорядочивание элементов по возрастанию или убыванию
НЕ сортируются элементы разных типов (строки и числа), т.к. их нельзя сравнивать (целые и вещественные числа можно, т.к. в обоих случаях число)
Сортировка текста - по кодам символов: английские буквы сортируются согласно кодировке АCSII, русские буквы - согласно utf-8, как и смайлики, у которых есть 
свой порядковый номер внутри таблицы кодирования unicod. 
Главное, не смешивать текст и числа.

- функция  sorted()
- метод sort()
- функция reversed()
- метод reverse()
- синтакс.сахар [::-1]
"""
# SORTED() функция - для ЛЮБЫХ последовательностей, но на выходе - всегда  сортированный СПИСОК

""" принимает на вход список и возвращает список с отсортированными данными (ипользует сортировку ким-сорт)
НЕ меняя при этом исходный список """

# my_list = [4, 8, 2, 9, 1, 7, 2]
# sort_list = sorted(my_list) # по возрастанию
# print(my_list, sort_list, sep='\n')
# # [4, 8, 2, 9, 1, 7, 2]
# # [1, 2, 2, 4, 7, 8, 9]
# rev_list = sorted(my_list, reverse=True) # убыванию
# print(my_list, rev_list, sep='\n')
# [4, 8, 2, 9, 1, 7, 2]
# [9, 8, 7, 4, 2, 2, 1]

# МЕТОД sort() - только для списков
"""
Когда не хотим создавать новый список, а хотим изменить (отсортировать) текущий 
Тут происходти сортировка in place (на месте)
"""
# my_list = [4, 8, 2, 9, 1, 7, 2]
# my_list.sort() 
# print(my_list) # [1, 2, 2, 4, 7, 8, 9]
# my_list.sort(reverse=True)
# print(my_list) # [1, 2, 2, 4, 7, 8, 9]

# REVERSED() - функция

"""делает РАЗВОРОТ переданного ей списка, но выдает на выходе НЕ список, поэтому нужно дополнительно
обернуть полученный после разворота результат в список

Другой вариант использования этой функции - в цикле, когда нужно перебирать элементы в обратном порядке (справа налево)"""

# my_list = [4, 8, 2, 9, 1, 7, 2]
# res = reversed(my_list)
# print(type(res), res) # <class 'list_reverseiterator'> <list_reverseiterator object at 0x000001DDD486F7F0>

# rev_list = list(reversed(my_list))
# print(rev_list) # [2, 7, 1, 9, 2, 8, 4]

# for item in reversed(my_list):
#    print(item)

# 2
# 7
# 1
# 9
# 2
# 8
# 4   

# МЕТОД REVERSE() - разворачивает элементы списка in place, не создавая новый элемент

# my_list = [4, 8, 2, 9, 1, 7, 2]
# my_list.reverse()
# print(my_list) # [2, 7, 1, 9, 2, 8, 4]

# # синтакс.сахар [::-1] - делаем срез от начала до конца списка с шагом -1, т.е. в обратном порядке.

# my_list = [4, 8, 2, 9, 1, 7, 2]
# new_list = my_list[::-1]
# print(my_list, new_list, sep='\n')

# [4, 8, 2, 9, 1, 7, 2]
# [2, 7, 1, 9, 2, 8, 4]

# СОЗДАНИЕ КОПИЙ

# СРЕЗЫ - list[start:stop:step]

"""
по умолчанию: start = 0, т.е. с первого элемента, stop = конец списка, step = 1
Стартовый элемент включается в срез, тот, который указан как stop - в срез не входит
"""

# my_list = [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
# print(my_list[2:7:2]) # [6, 8, 12]
# print(my_list[:7:2]) # [2, 6, 8, 12]
# print(my_list[2::2]) # [6, 8, 12, 16]
# print(my_list[2:7:]) # [6, 2, 8, 10, 12]
# print(my_list[8:3:-1]) # [16, 14, 12, 10, 8]
# print(my_list[3::]) # [2, 8, 10, 12, 14, 16, 18]
# print(my_list[:7:]) # [2, 4, 6, 2, 8, 10, 12]

# МЕТОД COPY()

# my_list = [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
# new_list = my_list # стал один и тот же объект
# print(my_list, new_list, sep='\n')
# # [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
# # [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]

# my_list[2] = 555 # замена значения элемента списка с индексом 2 на значение 555
# print(my_list, new_list, sep='\n')
# # [2, 4, 555, 2, 8, 10, 12, 14, 16, 18]
# # [2, 4, 555, 2, 8, 10, 12, 14, 16, 18]

# my_list = [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
# new_list = my_list.copy() # сделали ПОВЕРХНОСТНУЮ КОПИЮ списка (они независимы и являются разными объктами)
# print(my_list, new_list, sep='\n')
# # [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
# # [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]

# my_list[2] = 555
# print(my_list, new_list, sep='\n')
# # [2, 4, 555, 2, 8, 10, 12, 14, 16, 18]
# # [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]


# НО! (на примере матриц (матрица - список списков))
# МЕТОД COPY.DEEPCOPY() - НЕ только для списков. Метод рекурсивно обходит все структуры на всех уровнях вложенности

# matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
# new_m = matrix.copy()
# print(matrix, new_m, sep='\n')
# # [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
# # [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# matrix[0][1] = 555
# print(matrix, new_m, sep='\n')
# # [[1, 555, 3], [4, 5, 6], [7, 8, 9]]
# # [[1, 555, 3], [4, 5, 6], [7, 8, 9]]
# """ В этом случае поверхностной копии не достаточно, т.к. мы имеем 2 уровня вложенности (каждый элемент списка сам
# является списком. А поверхностная копия работает только с 1-м уровнем, второй не затронут, в итоге изменения в
# одном объекте отразились и на другом объекте (который был копией первого))
# """
# matrix[0] = 555 # тут заменяем элемент 1-го уровня вложенности, т.о. изменения не затрагивают новую матрицу (копию старой)
# print(matrix, new_m, sep='\n')
# # [555, [4, 5, 6], [7, 8, 9]]
# # [[1, 555, 3], [4, 5, 6], [7, 8, 9]]

"""для решения используется метод deepcopy() модуля copy (модуль нужно дополнително испортировать)"""

# import copy

# matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
# new_m = copy.deepcopy(matrix)
# print(matrix, new_m, sep='\n')
# matrix[0][1] = 555
# print(matrix, new_m, sep='\n')

# [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
# [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
# [[1, 555, 3], [4, 5, 6], [7, 8, 9]]
# [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

"""аккуратно использовать копирование, особено глубокое, т.к. может занимать сильно оперативную память"""

# ФУНКЦИЯ LEN() - ДЛЯ ЛЮБОЙ КОЛЛЕКЦИИ. У строки посчитает сколько символов, в кортеже - сколько элементов, 
# в словаре - сколько пар ключ-значение

"""
len(x) - возвращает целое число - количество элементов коллекции.
Не учитывает вложенные коллекции!
 """
# my_list = [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
# matrix = [[1, 2, 3], [4, 5, 6, 4], [7, 8, 9]]
# print(len(my_list)) # 10
# print(len(matrix)) # 3
# print(len(matrix[1])) # 4










