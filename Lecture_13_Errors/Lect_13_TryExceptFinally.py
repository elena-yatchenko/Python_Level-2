# КОМАНДА TRY

"""Что делать, если мы не хотим завершать программу в случае появления ошибки?
Команда try позволяет обернуть блок кода с возможной ошибкой и отловить её"""

"""Команда try: должна завершать строку двоеточием, а вложенный блок кода
пишется с отступами. Всё точно так же как с if, for, while и т.п

Блок кода внутри try в идеале должен состоять из одной строки
кода — потенциального источника ошибки. Оборачивание всей программы в
блок try считается плохим стилем программировани"""


# def get(text: str = None) -> int:
#     data = input(text)
#     try:
#         num = int(data)
#     return num

# if __name__ == '__main__':
#     number = get('Введите целый делитель: ')
#     print(f'100 / {number} = {100 / number}')

# SyntaxError: expected 'except' or 'finally' block 
"""Синтаксические ошибки обязательно исправлять в процессе создания программы, 
а не пытаться их обрабатывать."""

# КОМАНДА EXCEPT

"""Как вы верно догадались из текста синтаксической ошибки, команда try должна
работать в связке с командой except или finally."""

"""Рассмотрим вариант обработки ошибки в нашем коде:"""

# def get(text: str = None) -> int:
#     data = input(text)
#     try:
#         num = int(data)
#     except ValueError as e:
#         print(f'Ваш ввод привёл к ошибке ValueError: {e}')
#         num = 1
#         print(f'Будем считать результатом ввода число {num}')
#     return num

# if __name__ == '__main__':
#     number = get('Введите целый делитель: ')
#     print(f'100 / {number} = {100 / number}')
    
    
"""После зарезервированного слова except указывается класс ошибки, которую мы
хотим обработать. Обычно используется запись вида except NameError as e: Таким
образом в переменную e попадает информация об ошибке. Например для вывода
её в консоль, сохранения в логи и т.п."""

"""!!! Программа продолжает работать несмотря на ошибку."""

# ЦИКЛ WHILE ДЛЯ обработки ошибок ввода

"""Иногда необходимо получить данные повторно, если попытка не удалась. В случае с
пользователем можем спрашивать его бесконечно, пока не добъёмся ввода целого
числа."""

# def get(text: str = None) -> int:
#     while True:
#         try:
#             num = int(input(text))
#             break
#         except ValueError as e:
#             print(f'Ваш ввод привёл к ошибке ValueError: {e}\n'f'Попробуйте снова')
#     return num

# if __name__ == '__main__':
#     number = get('Введите целый делитель: ')
#     print(f'100 / {number} = {100 / number}')
    
# # Введите целый делитель: два 
# # Ваш ввод привёл к ошибке ValueError: invalid literal for int() with base 10: 'два'
# # Будем считать результатом ввода число 1
# # 100 / 1 = 100.0

# # Введите целый делитель: 5
# # 100 / 5 = 20.0   

"""Бесконечный цикл while True можно прервать командой break. В случае
преобразования ввода пользователя к целому без ошибок она завершит цикл и
вернёт число из функции. При появлении ошибки дальнейшие строки не
выполняются, сразу переходим в блок except. Обработав ошибку мы возвращаемся
к началу цикла, следовательно повторяем запрос."""

"""Подобное поведение можно применить не только к функции input, но и к любой
ситуации получения данных. Код ниже имитирует получение данных из источника
(база данных, сайт, удалённыё сервер и т.п.)."""

# MAX_COUNT = 5

# count = 0
# while count < MAX_COUNT:
#     count += 1
#     try:
#         data = get_data()
#         break
#     except ConnectionError as e:
#         print(f'Попытка {count} из {MAX_COUNT} завершилась ошибкой {e}')


# НЕСКОЛЬКО EXCEPT ДЛЯ ОДНОГО TRY

"""Как вы уже догадались при вводе нуля в примерах на деление выше мы получим
ошибку. Это ZeroDivisionError: division by zero.
Вспомним высшую математику, а именно то, что при делении любого числа на ноль
получаем бесконечность."""

# def hundred_div_num(text: str = None) -> tuple[int, float]:
#     while True:
#         try:
#             num = int(input(text))
#             div = 100 / num
#             break
#         except ValueError as e:
#             print(f'Ваш ввод привёл к ошибке ValueError: {e}\n'f'Попробуйте снова')
#         except ZeroDivisionError as e:
#             div = float('inf')
#             break
#     return num, div

# if __name__ == '__main__':
#     n, d = hundred_div_num('Введите целый делитель: ')
#     print(f'Результат операции: "100 / {n} = {d}"')
    
# # Введите целый делитель: ПЯТЬ
# # Ваш ввод привёл к ошибке ValueError: invalid literal for int() with base 10: 'ПЯТЬ'
# # Попробуйте снова

# # Введите целый делитель: 0
# # Результат операции: "100 / 0 = inf"

"""В приведённом примере блок try обрабатывает сразу несколько строчек, которые
способны вызвать разные ошибки. Не лучший вариант. Правильнее было бы
разделить код на отдельные try блоки со своими возможными исключениями. Но
зато мы познакомились с обработкой нескольких ошибок разом.
Если не удалось получить целое число, обрабатываем ошибку значения и даём ещё
один шанс. А если делим на ноль, вместо ошибки возвращаем бесконечность.
"""

"""Язык Python поддерживает такие математические числа как
бесконечность и минус бесконечность. Записываются они как особая форма
вещественного числа:
● float(‘inf’) - бесконечность
● float(‘-inf’) - минус бесконечность"""

# КОМАНДА ELSE

"""Если надо выполнить код ТОЛЬКО В СЛУЧАЕ УСПЕШНОГО ЗАВЕРШЕНИЯ БЛОКА TRY, можно
воспользоваться командой else в связке try-except-else
"""
# MAX_COUNT = 5

# result = None
# for count in range(1, MAX_COUNT + 1):
#     try:
#         num = int(input('Введите целое число: '))
#         print('Успешно получили целое число')
#     except ValueError as e:
#         print(f'Попытка {count} из {MAX_COUNT} завершилась ошибкой {e}')
#     else:
#         result = 100 / num
#         break
    
# print(f'{result = }')

# # Введите целое число: THREE
# # Попытка 1 из 5 завершилась ошибкой invalid literal for int() with base 
# # 10: 'THREE'

# # Введите целое число: 25
# # Успешно получили целое число
# # result = 4.0

"""В приведённом примере пользователь вводит число. Если получаем ошибку,
сообщаем о ней пользователю. Всего даём MAX_COUNT попыток. Но стоит успешно
преобразовать текст в целое как сработает блок else. Он сохранит результат
деления и завершит цикл попыток."""

"""Если внутри блока try произойдёт одно из событий ниже, блок else не будет вызван:
● возбуждено исключение
● выполнена команда return
● выполнена команда break
● выполнена команда continue
Именно по этой причине в нашем примере break перекочевал из try в else.
Блок else может быть лишь один и обязан следовать за блоком except."""

# ВЛОЖЕННЫЕ БЛОКИ ОБРАБОТКИ ИСКЛЮЧЕНИЙ

"""При необходимости одни try блоки могут включать другие. Аналогично работа.т
вложенные циклы или вложенные if — сложные ветвления.
Перепишем код выше так, чтобы ошибка деления на ноль обрабатывалась внутри
блока else верхнего try."""

# MAX_COUNT = 5

# result = None
# for count in range(1, MAX_COUNT + 1):
#     try:
#         num = int(input('Введите целое число: '))
#         print('Успешно получили целое число')
#     except ValueError as e:
#         print(f'Попытка {count} из {MAX_COUNT} завершилась ошибкой {e}')
#     else:
#         try:
#             result = 100 / num
#         except ZeroDivisionError as e:
#             result = float('inf')
#         break
    
# print(f'{result = }')

# # Введите целое число: 0
# # Успешно получили целое число
# # result = inf

"""Если удалось получить целое число, заглядываем в else и пытаемся делить. Но если
деление на ноль, возвращаем бесконечность вместо ошибки."""

# КОМАНДА FINALLY

"""Ещё одна команда для обработки исключений — finally. Она срабатывает во всех
случаях. И если была ошибка и отработал блок except. И если ошибки не было."""

def get(text: str = None) -> int:
    num = None
    try:
        num = int(input(text))
    except ValueError as e:
        print(f'Ваш ввод привёл к ошибке ValueError: {e}')
    finally:
        return num if isinstance(num, int) else 1
    
if __name__ == '__main__':
    number = get('Введите целый делитель: ')
    try:
        print(f'100 / {number} = {100 / number}')
    except ZeroDivisionError as e:
        print(f'На ноль делить нельзя. Получим {e}')
        
# # Введите целый делитель: 25
# # 100 / 25 = 4.0

# # Введите целый делитель: TWO
# # Ваш ввод привёл к ошибке ValueError: invalid literal for int() with base 10: 'TWO'
# # 100 / 1 = 100.0

# # Введите целый делитель: 0
# # На ноль делить нельзя. Получим division by zero
        
"""Даём пользователю одну попытку на ввод числа. Независимо от результата
сработает блок finally. Он вернёт либо целое число, либо единицу, если получить
целое не удалось. Обработку деления на ноль вынесли в основной код.
Обычно finally используют для действий, которые обязательны независимо от того
была ошибка или нет."""

# БЛОК FINALLY БЕЗ EXCEPT

"""Вполне допустимо использовать только связку try-finally. Например мы хотим
прочитать информацию из файла. И независимо от результат чтения закрыть его."""

# file = open('text.txt', 'r', encoding='utf-8')
# try:
#     data = file.read().split()
#     print(data[len(data)])
# finally:
#     print('Закрываю файл')
#     file.close()
    
"""Открываем файл для чтения, скачиваем его и сохраняем каждую строку в
отдельную ячейку списка. Но внезапно “забываем”, что нумерация начинается с
нуля, а для доступа к последнему элементу можно использовать индекс -1. В
результате попытка прочитать информацию из ячейки, следующей за последней
10
выдаёт ошибку IndexError: list index out of range. Но блок finally закрывает файл
раньше, чем программа завершит свою работу"""

"""!!! Для ситуации выше правильным будет использовать менеджер
контекста для гарантированного закрытия файла."""

# TEST

# d = {'42': 73}
# try:
#     key, value = input('Ключ и значение: ').split()
#     if d[key] == value:
#         r = 'Совпадение'
# except ValueError as e:
#     print(e)
# except KeyError as e:
#     print(e)
# else:
#     print(r)
# finally:
#     print(d)
    
# >>> Ключ и значение: 42 13
# {'42': 73}
# NameError: name 'r' is not defined - r не определено (не совпало), такую ошибку не обрабатывали

# >>> Ключ и значение: 42 73 3
# too many values to unpack (expected 2) - ValueError
# {'42': 73}

# >>> Ключ и значение: 73 42
# '72' - KeyError
# {'42': 73}

# >>> Ключ и значение: 42 73
# {'42': 73}
# NameError: name 'r' is not defined -r не определено, т.к. при вводе 73 - строка, 
# а в словаре - целое число.