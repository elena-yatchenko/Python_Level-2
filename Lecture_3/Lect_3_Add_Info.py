# ПРОВЕРКА НА ВХОЖДЕНИЕ IN
"""
Зарезервированное слово in позволяет сделать проверку на вхождение элемента в коллекцию
Линейное время проверки вхождения: (медленнее, т.к. идет проверка всех подряд элементов)
obj in list
obj in tuple
sub_str in str

Константное время проверки вхождения: (быстрее, т.к. ключи и значения множеств
являются неизменяемыми и уникальными и тут проверка работает с использованием технологии
хэширования. Т.е. мы вычисляем хэш элемента, который хотим проверить, входит он в коллекцию 
или нет. Т.о. получаем доступ к нужной ячейке: если она занята - элемент входит в коллекцию, 
если свободна - не входит)
key in dict
obj in set
obj in frozenset
"""
# my_set = {3, 4, 2, 5, 6, 1, 7}
# print(42 in my_set) # False


# Байты, bytes и bytearray

"""
Если хотим переслать что-то по каналам связи (любым) - это обмен байтами
"""

# Получение байт из строки
# text_en = "Hello world!"
# res = text_en.encode('utf-8')
# print(res, type(res)) # b'Hello world!' <class 'bytes'>

"""
Когда кодируем строку, состоящую из единичных байтов, а таблица кодирования ASCII, которая 
тоже однобайтовая, то мы видим на печати тот же текст 'Hello world', но с приставкой b впереди, 
что указывает, что перед нами тип данных не строка, а байты
"""

# text_ru = 'Привет, мир!'
# res = text_ru.encode('utf-8')
# print(res, type(res))
"""
В русском языке каждый символ занимает 2 байта, поэтому на выходе уже видим строку из байт, где 
каждый элемент начинается с х (что говорит, что перед нами строка байт) и 2 цифры
в 16-тиричной системе счисления (10 цифр: 0-9 и 6 букв: a-f)
"""
# b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82, \xd0\xbc\xd0\xb8\xd1\x80!' <class 'bytes'>

# Получение байт из форматированной строки (явно указываем последовательность байт, которую хотим передать)

"""
функция bytes - если нам нужна НЕизменяемая последовательность
функция bytearray - если нам нужна изменяемая последовательность

x = bytes(b'\xd0\x9f.......xb8')
y = bytearray(b'\xd0\x9f.......xb8') -  в такой последовательности можно обращаться к элементу
по индексу и вносить изменения в набор байт
"""        
x = bytes(b'\xd0\x9f\xb8')
y = bytearray(b'\xd0\x9f\xb8')

print(f'{x = }\n{y = }')

# x = b'\xd0\x9f\xb8'
# y = bytearray(b'\xd0\x9f\xb8')