# СОЗДАНИЕ И УДАЛЕНИЕ экземпляра класса

"""Дандер — имя переменной, начинающейся и заканчивающейся двумя
подчеркиваниями. В Python такие переменные используются для создания
специальных свойств и методов объекта, влияющих на его поведение"""

# СОЗДАНИЕ ЭКЗЕМПЛЯРА КЛАССА, __INIT__

"""За создание экземпляра класса отвечает дандер метод __init__."""

# class User:
    
#     def __init__(self, name: str, equipment: list = None):
#         self.name = name
#         self.equipment = equipment if equipment is not None else []
#         self.life = 3
# # принтим только в учебных целях, а не для реальных задач
#         print(f'Создал {self} со свойствами:\n'
#                 f'{self.name = },\t{self.equipment = },\t{self.life = }')

# print('Создаём первый раз')
# u_1 = User('Спенглер')
# print('Создаём второй раз')
# u_2 = User('Венкман', ['протонный ускоритель', 'ловушка'])
# print('Создаём третий раз')
# u_3 = User(equipment=['ловушка', 'прибор ночного видения'], name='Стэнц')

# # Создаём первый раз
# # Создал <__main__.User object at 0x0000021BDFF6EE90> со свойствами:
# # self.name = 'Спенглер', self.equipment = [],    self.life = 3     
# # Создаём второй раз
# # Создал <__main__.User object at 0x0000021BDFF6EE50> со свойствами:
# # self.name = 'Венкман',  self.equipment = ['протонный ускоритель', 
# # 'ловушка'],     self.life = 3
# # Создаём третий раз
# # Создал <__main__.User object at 0x0000021BDFF6EED0> со свойствами:
# # self.name = 'Стэнц',    self.equipment = ['ловушка', 'прибор ночного видения'],   self.life = 3

"""Вызов
класса - это указание его имени с круглыми скобками после. Такой вызов
автоматически перенаправляется в метод __init__. По сути мы вызвали его,
следовательно возможность передавать аргументы при создании экземпляра
прописывается параметрами “инит”."""

"""!!! Важно! Постарайтесь разобраться в работе дандер метода __init__. Он
встречается чаще других и определяет структуру экземпляров. В подавляющем
большинстве (если речь не идёт о метапрограммировании) внутри метода
прописываются все свойства экземпляра"""

# КОНТРОЛЬ СОЗДАНИЯ КЛАССА ЧЕРЕЗ __NEW__

"""Метод __new__ срабатывает раньше __init__ (создание экземпляра класса) и определяет что должен вернуть
класс в качестве себя - класса. Т.е. туда можно добавлять код, который должен что-то 
делать до создания непосредственно экземпляра класса (проверки и т.п.) Рассмотрим вначале общий пример."""

# class User:
    
#     def __init__(self, name: str):
#         self.name = name
#         print(f'Создал {self.name = }')
        
#     def __new__(cls, *args, **kwargs):
#         instance = super().__new__(cls)
#         print(f'Создал класс {cls}')
#         return instance
    
# print('Создаём первый раз')
# u_1 = User('Спенглер')
# 5
# print('Создаём второй раз')
# u_2 = User('Венкман')
# print('Создаём третий раз')
# u_3 = User(name='Стэнц')

# # Создаём первый раз
# # Создал класс <class '__main__.User'>
# # Создал self.name = 'Спенглер'
# # Создаём второй раз
# # Создал класс <class '__main__.User'>
# # Создал self.name = 'Венкман'
# # Создаём третий раз
# # Создал класс <class '__main__.User'>
# # Создал self.name = 'Стэнц'

"""Метод __new__ принимает в качестве первого параметра сам себя. Обычно
используют слово cls — сокращение от class. Так понятно, что мы работаем с
классом, а не с его экземпляром. Параметры *args, **kwargs нужны для правильной
работы метода __init__ и попадания в него любых аргументов.
Внутри __new__ необходимо вызвать аналогичный родительский метод. Он
возвращает класс, который можно модифицировать прежде чем вернуть из метода."""

# РАСШИРЕНИЕ НЕИЗМЕНЯЕМЫХ КЛАССОВ

"""Один из вариантов использования дандер __new__ — расширение
функциональности уже имеющихся неизменяемых классов Python. Например мы
хотим использовать переменную целого типа, которая дополнительно хранит
присвоенное числу имя."""

# class NamedInt(int):
    
#     def __new__(cls, value, name):
#         instance = super().__new__(cls, value)
#         instance.name = name
#         print(f'Создал класс {cls}')
#         return instance
    
# print('Создаём первый раз')
# a = NamedInt(42, 'Главный ответ жизни, Вселенной и вообще')
# print('Создаём второй раз')
# b = NamedInt(73, 'Лучшее просто число')
# print(f'{a = }\t{a.name = }\t{type(a) = }')
# print(f'{b = }\t{b.name = }\t{type(b) = }')
# c = a + b
# print(f'{c = }\t{type(c) = }')

# # Создаём первый раз
# # Создал класс <class '__main__.NamedInt'> # __main__ - название модуля, т.к. запускаем с того же файла? поэтому main
# # Создаём второй раз
# # Создал класс <class '__main__.NamedInt'>
# # a = 42  a.name = 'Главный ответ жизни, Вселенной и вообще'      type(a) = <class '__main__.NamedInt'>
# # b = 73  b.name = 'Лучшее просто число'  type(b) = <class '__main__.NamedInt'>
# # c = 115 type(c) = <class 'int'>

"""Параметр value нужен для передачи значения в родительский класс int. Далее к
целому числу добавляется параметр name с переданным значением. После
создания объекта он возвращается для присваивания переменной.
Обратите внимание, что наш класс унаследовал всё, что умеет класс int. Мы смогли
сложить два числа и получить обычное целое число без свойства name.
"""

# ШАБЛОН ОДИНОЧКА, SINGLETON

"""Ещё один вариант использования дандре __new__ — паттерн Singleton. Он
позволяет создавать лишь один экземпляр класса. Вторая и последующие попытки
будут возвращать ранее созданый экземпляр.

 Это не единственный вариант создания паттерна Одиночка в
Python, а версия через __new__
"""

# class Singleton:
#     _instance = None

#     def __new__(cls, *args, **kwargs):
#         if cls._instance is None:
#             cls._instance = super().__new__(cls)
#         return cls._instance
    
#     def __init__(self, name: str):
#         self.name = name
        
# a = Singleton('Первый')
# print(f'{a.name = }')
# b = Singleton('Второй')
# print(f'{a is b = }')
# print(f'{a.name = }\n{b.name = }')

# # a.name = 'Первый'
# # a is b = True
# # a.name = 'Второй'
# # b.name = 'Второй'

"""Защищенная переменная _instance хранит None и при создании первого
экземпляра получает на него ссылку. Благодаря *args, **kwargs в методе __new__
аргумент “Первый” проваливается в метод __init__ и попадает в параметр name.
При создании экземпляра второй раз возвращается его первая версия и у неё
заменяется свойство name. Переменные a и b ссылаются на один и тот же класс, а
следовательно их свойство name общее.
"""

# УДАЛЕНИЕ ЭКЗЕМПЛЯРА КЛАССА, __DEL__

"""Дандер метод __del__ также редко используется в обычной практике ООП. Он
отвечает за действия при удалении экземпляра класса. Если быть более точным,
метод срабатывает при достижении нуля счётчиком ссылок на объект, но перед его
удалением из памяти сборщиком мусора."""

# class User:
    
#     def __init__(self, name: str):
#         self.name = name
#         print(f'Создал {self.name = }')
        
#     def __del__(self):
#         print(f'Удаление экземпляра {self.name}')
        
# u_1 = User('Спенглер')
# u_2 = User('Венкман')

# # Создал self.name = 'Спенглер'
# # Создал self.name = 'Венкман'
# # Удаление экземпляра Спенглер
# # Удаление экземпляра Венкман

"""Python в любом случае удалил бы экземпляры и освободил
память, даже если дандер __del__ не прописан"""

# КОМАНДА DEL

"""Зарезервированное слово del не удаляет объекты в Python. Оно разрывает связь
между переменной и объектом, на который переменная указывает. После строки с
del к переменной нельзя обратиться, а у объекта на единицу уменьшается счётчик
ссылок.
"""
# import sys

# class User:
    
#     def __init__(self, name: str):
#         self.name = name
#         print(f'Создал {self.name = }')
        
#     def __del__(self):
#         print(f'Удаление экземпляра {self.name}')
        
# u_1 = User('Спенглер')
# print(sys.getrefcount(u_1)) # счетчик ссылок на объект
# u_2 = u_1
# print(sys.getrefcount(u_1), sys.getrefcount(u_2))
# del u_1
# print(sys.getrefcount(u_1)) # NameError: name 'u_1' is not defined. Did you mean: 'u_2'?
# print(sys.getrefcount(u_2))
# print('Завершение работы')

# # Создал self.name = 'Спенглер'
# # 2  # 2, потому что в момент запуска getrefcount() тоже создает ссылку на этот объект, и ее учитывает в счете
# # 3 3
# # 2
# # Завершение работы
# # Удаление экземпляра Спенглер

"""В момент первого вызова метода getrefcount имеем одно значение счётчика ссылок.
Когда переменная u_2 получает ссылку на тот же объект, счётчик ссылок
увеличивается на единицу. Команда del уменьшает счётчик на единицу. А удаление
объекта происходит после завершения кода.

Счётчик ссылок возвращает значение больше ожидаемого, так
как сама функция создаёт дополнительную ссылку на объект при вызове.

Если в коде дописать del u_2 в предпоследней строке, удаление объекта
произойдёт раньше завершения работы программы. Счётчик ссылок дошёл до нуля
и сборщик мусора освободил память
"""

# TEST

class Count:
    _count = 0
    _last = None
    
    def __new__(cls, *args, **kwargs):
        if cls._count < 3:
            cls._last = super().__new__(cls)
            cls._count += 1
        return cls._last
    
    def __init__(self, name: str):
        self.name = name
        
"""класс работает аналогично методу класса одиночки, но позволяет создать максимум
3 экземпляра. После будет возвращать значение 3-го экземпляра для всех последующих"""

