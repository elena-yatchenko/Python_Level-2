# ИМПОРТ МОДУЛЕЙ

"""
Строки импорта рекомендуется писать в самом начале файла, оставляя 1-2 
пустые стркои после него
"""
# import sys

# print(sys) # <module 'sys' (built-in)>
# print(sys.builtin_module_names)
# print(*sys.path, sep='\n')

# ('_abc', '_ast', '_bisect', '_blake2', '_codecs', '_codecs_cn', 
# '_codecs_hk', '_codecs_iso2022', '_codecs_jp', '_codecs_kr', '_codecs_tw', 
# '_collections', '_contextvars', '_csv', '_datetime', '_functools', 
# '_heapq', '_imp', '_io', '_json', '_locale', '_lsprof', '_md5', 
# '_multibytecodec', '_opcode', '_operator', '_pickle', '_random', 
# '_sha1', '_sha256', '_sha3', '_sha512', '_signal', '_sre', '_stat', 
# '_statistics', '_string', '_struct', '_symtable', '_thread', '_tokenize', 
# '_tracemalloc', '_typing', '_warnings', '_weakref', '_winapi', 
# '_xxsubinterpreters', 'array', 'atexit', 'audioop', 'binascii', 
# 'builtins', 'cmath', 'errno', 'faulthandler', 'gc', 'itertools', 
# 'marshal', 'math', 'mmap', 'msvcrt', 'nt', 'sys', 'time', 'winreg', 
# 'xxsubtype', 'zlib')

"""
Переменная sys.path формируется динамически. В зависимости от того, с какого 
компьютера запускаете, будет прописывать путь к папкам.
В качестве первого адреса указывается путь до основного файла (ваш текущий проект).
Далее в sys.path перечислены пути из PYTHONPATH и пути, указанные при
установке Python и создании виртуального окружения. Таким образом Python ищет
импортируемый модуль практически во всех местах, где этот модуль мог быть
установлен. Если не нашел модуль - ошибка.
"""

# АНТИПРИМЕРЫ ВЫЗОВА МОДУЛЕЙ

# def randint(*args):  # создали свою функцию, но назвали так, как называется встроенный модуль в питоне
#     return 'Не то, что вы искали!'

# import random

# print(random.randint(1, 6)) # ожидаем случайное число в диапазоне от 1 до 6

"""но получим строку 'Не то, что вы искали!', т.к. питон нашел в соседней 
папке нашу созданную функцию и ее вытащил. Если хотите создать функцию с 
названием, как у встроенного модуля, ставить после нее знак нижнего подчеркивания_
randint_ """

# ИСПОЛЬЗОВАНИЕ FROM И AS

"""Это встроенные команды для импорта:
- через from указываем название модуля и импортировать что-то конкретное из него
from sys import builtin_module_names
- команда as позволяет задать псевдоним, по которому будем обращаться к модулю
import numpy as np
Их можно сочетать между собой
!!! При таком способе вызова возможность обращения через точку (modul.path) - уже
работать не будет, т.к. мы вызываем конкретные переменные и можем обращаться к 
ним напрямую
"""

# from sys import builtin_module_names, path

# print(builtin_module_names)
# print(*path, sep='\n')

# import random as rnd
# from sys import builtin_module_names as bmn, path as p
# можно импортировать сразу несколько модулей

# print(bmn)
# print(*p, sep='\n')
# print(rnd.randint(1, 6))
# print(path) # NameError: name 'path' is not defined - такого названия нет,мы присвоили другое
# print(sys.path) # NameError: name 'sys' is not defined - модуль sys напрямую не был испортирован

# ПЛОХОЙ import * (импорт звездочка) - не рекоменд. в сообществе Питон

""" 
from имя_модуля import *
!!!! Подобная запись импортирует из модуля все ГЛОБАЛЬНЫЕ объекты, ЗА ИСКЛЮЧЕНИЕМ ТЕХ, 
ЧЬИ ИМЕНА НАЧИНАЮТСЯ С СИМВОЛА НИЖНЕГО ПОДЧЕРКИВАНИЯ "_". и НЕ импортирует
ЛОКАЛЬНЫЕ объекты
"""

from random import randint

# создал свой модуль - super_module.

SIZE = 100 # - ГЛОБАЛЬНАЯ
_secret = 'qwerty' # защищенная переменная (с 1 "_") - ГЛОБАЛЬНАЯ
__top_secret = '1q2w3e4r5t6y' # приватная переменная (с 2 "_") - ГЛОБАЛЬНАЯ

def func(a: int, b: int) -> str:
    z = f'В диапазоне от {a} до {b} получили {randint(a, b)}'
    return z

result = func(1, 6)
# a, b, z - ЛОКАЛЬНЫЕ ПЕРЕМЕННЫЕ (существуют только внутри функции)
# result - ГЛОБАЛЬНАЯ

#from super_module import *

SIZE = 49.5

print(f'{SIZE = }\n{result = }') 
    # SIZE = 49.5 - была пересоздана после вызова модуля
    # result = 'В диапазоне от 1 до 6 получили 6' - переменная была глобальной и дала значение
# print(f'{z = }')
    # NameError: name 'z' is not defined - она локальная. При вызове метода через * 
    # НЕ можем получать доступ к локальным объектам
print(f'{_secret = }')
    # NameError: name '_secret' is not defined - переменная глобальная, но знак "_"
    # делает ее защищенной, а защищенные переменные при вызове через * НЕ импортируются
print(f'{func(100, 200) = }\n{randint(10, 20) = }')
    # func(100, 200) = 'В диапазоне от 100 до 200 получили 193'
    # randint(10, 20) = 11
def func(a: int, b: int) -> int:
    return a + b


print(f'{func(100, 200) = }')
    # func(100, 200) = 300

"""
!!! Решение: использование переменной __all__, которая содержит в себе СПИСОК [], 
внутри которого перечисляются имена объектов (в кавычках '', т.е. СТРОКОВЫЕ значения)
и именно эти значения (уже как переменные, не строки) будут импортированы 
в модуль, если мы запустим вариант  импорта со *
!!! НО: теперь сюда в список __all__ нужно перечислять ВСЕ нужные переменные модуля (в т.ч. 
и ГЛОБАЛЬНЫЕ), иначе они будут не доступны
... Внутри встроенных модулей (вроде random) разработчики уже позаботились о 
переменной __all__, содержащей все нужное
! Переменная __all__ прописывается в начале вашего модуля
"""

from random import randint

__all__ = ['func', '_secret']

SIZE = 100 # - ГЛОБАЛЬНАЯ
_secret = 'qwerty' # защищенная переменная (с 1 "_") - ГЛОБАЛЬНАЯ
__top_secret = '1q2w3e4r5t6y'