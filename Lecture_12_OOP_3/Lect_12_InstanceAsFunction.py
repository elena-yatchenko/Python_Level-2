# ЭКЗЕМПЛЯР КЛАССА КАК ФУНКЦИЯ

"""При желании можно заставить класс, а точнее его экземпляры вести себя как
функции. После имени экземпляра указываются круглые скобки с параметрами для
вызова и экземпляр возвращает ответ"""

# class Number:
#     def __init__(self, num):
#         self.num = num
# n = Number(42)
# print(f'{callable(Number) = }') # callable(Number) = True
# print(f'{callable(n) = }')  # callable(n) = False

"""Класс Number имеет метод инициализации для сохранения числа. Мы создали
экземпляр класса n и воспользовались встроенной функцией callable. Для класса
получили истину, для экземпляра ложь. Функция callable отвечает на вопрос вызываемый
перед нами объект или нет (т.е. может ли он работать как функция: круглые скобки, 
аргументы, возврат результата работы функции). Вызов класса возможен. 
Он запускает инициализацию и возвращает экземпляр. Вызвать экземпляр нельзя"""

# МЕТОД ВЫЗОВА ФУНКЦИИ __CALL__

"""Создадим класс, экземпляры которого можно вызывать. Например для добавления
очередного элемента во внутренний словарь класса по типам."""

# from collections import defaultdict

# class Storage:

#     def __init__(self):
#         self.storage = defaultdict(list)

#     def __str__(self):
#         txt = '\n'.join((f'{k}: {v}' for k, v in self.storage.items()))
#         return f'Объекты хранилища по типам:\n{txt}'

#     def __call__(self, value):
#         self.storage[type(value)].append(value)
#         return f'К типу {type(value)} добавлен {value}'

# s = Storage()
# print(s(42))
# print(s(72))
# print(s('Hello world!'))
# print(s(0))
# print(s)

# # К типу <class 'int'> добавлен 42
# # К типу <class 'int'> добавлен 72
# # К типу <class 'str'> добавлен Hello world!
# # К типу <class 'int'> добавлен 0
# # Объекты хранилища по типам:
# # <class 'int'>: [42, 72, 0]
# # <class 'str'>: ['Hello world!']

"""При создании класса используется продвинутая версия словаря из модуля
collections — DEFAULTDICT. Словарю передана функция list. При обращении к
несуществующему ключу вместо ошибки (как в обычном словаре) будет создан ключ (которого не существовало и который не нашли при обращении)
и вызвана функция list, которая в качестве значения ключа создаст пустой список [].
 
Каждый вызов экземпляра добавляет переданный аргумент value в словарь storage
и возвращает строку с информацией о выполненном действии.

!!! Плюсом вызова экземпляра является то, что он не удаляется из памяти после
вызова как обычная функция. Следовательно экземпляр может накапливать
значения, использоваться в технологии мемоизации. Её рассматривали на лекции о
декораторах."""

# TEST

# class MyClass:
#     def __init__(self, a, b):
#         self.a = a
#         self.b = b

#     def __repr__(self):
#         return f'MyClass(a={self.a}, b={self.b})'

#     def __call__(self, *args, **kwargs):
#         self.a.append(args)
#         self.b.update(kwargs)
#         return True

# x = MyClass([42], {73: True})
# y = x(3.14, 100, 500, start=1)
# x(y=y)
# print(x)

# # MyClass(a=[42, (3.14, 100, 500), ()], b={73: True, 'start': 1, 'y': True})
