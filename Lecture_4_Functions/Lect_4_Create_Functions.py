# ФУНКЦИИ
""" 
Фукнция - это фрагмент кода, к которому можно обратиться из другого
места программы. 
Данные на вход - Функция - Результат (Данные на выход)

ФУНКЦИЯ ВЫСШЕГО ПОРЯДКА - функция, которая принимает функцию-объект как аргумент
или возвращает функцию-объект в виде выходного значения
"""
# a = 42
# # вызываем функцию id
# print(type(a), id(a))  # <class 'int'> 140707942295624
# # передаем функцию id как аргумент
# print(type(id))  # <class 'builtin_function_or_method'>

# """Когда функция вызывается, у нее есть всегда (), когда передается в
# другую функкцию в качестве аргумента, то без скобок"""

# very_bad_programming_style = sum
# # плохой стиль, т.к. используем другое имя для уже существующей функции
# print(very_bad_programming_style([1, 2, 3]))  # 6

# СОЗДАНИЕ ФУНКЦИЙ

# def - от define (определять)

# def my_func():
#     pass

"""Чтобы функция работала, ее нужно не забывать ВЫЗВАТЬ

Зарезервированное слово pass нужно для того, чтобы "ничего не делать".
Т.е. иногда мы обязаны написать какую-то строку кода, но он ничего не делает, тогда используем pass
Например, создаем функцию, но внутренний блок пока не заполнен (тело фукнции), 
или в ООП, когда создаем классы, но пока не прописываем внутри логику
"""
# плохо
# if a != S:
#     pass
# else:
#     a += 1

# # лучше (в некоторых ЯП else является обязательным при if, тогда pass помогает)
# if a == S:
#     a += 1
# else:
#     pass

# # отлично
# if a == S:
#     a += 1

# АРГУМЕНТЫ ФУНКЦИИ - указываются через запятую в круглых скобках после имени функции
# * когда мы определяем функцию аргументы называются параметрами функции, при ее вызове
# и работе - это уже аргументы

# def quadratic_equations(
#     a: int | float, b: int | float, c: int | float
# ) -> tuple[float, float] | float | str:
#     d = b**2 - 4 * a * c
#     if d > 0:
#         return (-b + d**0.5) / (2 * a), (-b - d**0.5) / (2 * a)
#     if d == 0:
#         return -b / (2 * a)
#     return "Нет решений"

# print(quadratic_equations(2, -3, -9))  # (3.0, -1.5)
"""
минус такой записи: на выходе придется проверять, мы получили строку
или числа. Чтобы это исключить, можно скорректировать функцию, добавив
вместо строки - None для варианта, когда нет корней. Это более универсальный
подход, чем сочетание разных типов данных
"""
def quadratic_equations(
    a: int | float, b: int | float, c: int | float
) -> tuple[float, float] | float | None:
    d = b**2 - 4 * a * c
    if d > 0:
        return (-b + d**0.5) / (2 * a), (-b - d**0.5) / (2 * a)
    if d == 0:
        return -b / (2 * a)
    return None

# ИЗМЕНЯЕМЫЕ И НЕИЗМЕНЯЕМЫЕ АРГУМЕНТЫ
"""
При передаче объекта в фукнцию нужнопомнить, изменяемого типа объект или нет
Неизменяемый аргумент - при изменении внутри функции остается прежним вне функции
Изменяемый аргумент - при изменении внутри функции изменяется и за ее пределами

!!! В Python аргументы передатся внутри функции по ссылке на объект
"""


# def no_mutable(a: int) -> int:
#     a += 1
#     print(f"In func {a = }")  # для демонстрации работы, но не для привычки принтить из фукнции
#     return a

# a = 42
# print(f"In main {a = }")  # In main a = 42
# z = no_mutable(a)  # In func a = 43
# print(f"{a = }\t{z = }")  # a = 42  z = 43

# def mutable(data: list[int]) -> list[int]:
#     for i, item in enumerate(data):
#         data[i] = item + 1
#     print(f'In func {data = }')
#     return data

# my_list = [2, 4,6, 8]
# print(f'in main {my_list = }') # in main my_list = [2, 4, 6, 8]
# new_list = mutable(my_list) # In func data = [3, 5, 7, 9]
# print(f'{my_list = }\t{new_list = }') 
# # my_list = [3, 5, 7, 9] new_list = [3, 5, 7, 9]

# ВОЗВРАТ ЗНАЧЕНИЯ ИЗ ФУНКЦИИ, RETURN
"""
print внутри функции - не лучший вариант, обычно не используют
обычно использование - return (возврат значения). При этом:
- если указан один объект после return - возвращается именно этот объект
- если указано несколько значений через запятую после return - возвращается 
кортеж с перечисленными значениями
- если не указано ничего после return - возвращается None
- если return отсутствует, Python 'мысленно' дописывает в качестве последней
строки функции return None
!!!! Когда срабатывает return функции, если там были другие строки кода, они уже не
принимаются в работу
"""
# для примера рассмотрим ту же функцию, которая считает квадр.уравнения

print(quadratic_equations(2, -3, -9)) # (3.0, -1.5)



